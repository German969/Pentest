import random

class DSA(object):
    def __init__(self, p, q):
        self.p = p
        self.q = q
        self.x = random.randint(1, self.q - 1) # private key # entre 1 y 10
        print('x: '+str(self.x))
        self.g = random.randint(1, self.p * self.q) # entre 1 y 253
        print('g: '+str(self.g))
        self.y = (self.g ** self.x) % self.p # public key
        print('y: '+str(self.y))
        print('p*q: '+str(p*q))
        print('g**x: '+str(self.g**self.x))
        print('y = g**x % p : '+str((self.g**self.x) % p))

    def dsa_sign(self, message):
        k = random.randint(1, self.q)
        r = 0
        s = 0
        while True:
            r = ((self.g**k) % self.p) % self.q
            if r == 0:
                k = random.randint(r, self.q)
                continue
            mod_inv = mod_inverse(k, self.q) # any implementation of modular multiplicative inverse
            s = mod_inv * (message + self.x * r)
            s = s % self.q
            if s == 0:
                k = random.randint(1, self.q)
                continue
            return (int(r), int(s))

    def dsa_verify(self, message, r, s):
        if not r > 0:
            return False
        if not r < self.q:
            return False
        if not s > 0:
            return False
        if not s < self.q:
            return False
        w = mod_inverse(s, self.q) # any implementation of modular multiplicative inverse
        u1 = (message * w) % self.q
        u2 = (r * w) % self.q
        v = (((self.g**u1)*(self.y**u2)) % self.p ) % self.q
        if v == r:
            return True
        return False
		
a = DSA(23,11)