different encoding in request -> XSS
dynamic csrf token -> CSRF
cookie domain scope

XSS
where it goes, 
embedded in a tag attribute?, 
into a string in a script tag?

special handling,
url get turned into link?

special characters,
accept '<>:;" ?

para explotar rXSS con POST necesitas CSRF

Si pasan las comillas dobles " pero no <>
usamos DOM events
ej: http://"onmouseover="alert(1);
>>> <a href="http://"onmouseover="alert(1);">

Si el input se ve reflejado en un script
payload: '; alert(1); '
result: <script>var token = ''; alert(1);

Si escapa los strings
payload: </script><script>alert(1);</script>
result: <script> var token = '</script><script>alert(1);</script>';</script>

MITIGATION
replace < with \x3c and > with \x3e
(don't work if you pass a integer to a DOM or a variable in a script)
for numbers or booleans convert to that type

DOM XSS depends entirely on js, not backend
document.write('<img src="lalal'+x+'.png"');

exploit: http://example.com/#''><script>alert(1);</script>

case: embedded data into eval/setTimeout/setInterval
mitigation: string scaping/filtering

case: ebedding data into tags and attributes
mitigation: html encoding

case: innerHTML
mitigation: HTML encoding

DON'T PUT USER INFO IN THE PAGE DIRECTLY
-whitelis very specific things
-if you really need it, escape/encode for specific context

Forced Browsing / Improper Authorization
Forced Browsing -> direct object reference
Both are authorizatino bugs or auth-z

example: permalink http://h101levels.appspot.com/levels/1/post?id=465
change the id to give a post for a different user

Perform every action as privileged user and then change to a lower one
and change IDs/CSRF tokens as needed

Finding XSS
"><h1>test</h1>
'+alert(1)+'
"onmouseover="alert(1)
http://"onmouseover="alert(1)

